{"title":"Recent updates to tidyverse functions","markdown":{"yaml":{"title":"Recent updates to tidyverse functions","author":"Matt Russell","description":"A few key updates from Teaching the tidyverse in 2023","date":"2023-09-14","slug":[],"categories":["Analytics"],"tags":["analytics","data science","R","tidyverse"],"image":"hex-tidyverse.png"},"headingText":"The native pipe works.","containsRefs":false,"markdown":"\n\n<center>\n\n![](hex-tidyverse.png){width=250px}\n</center>\n\nI recently watched the video [\"Teaching the tidyverse in 2023\"](https://youtu.be/KsBBRHAgAhM?si=Csp18DrhZhFe7r8x) by Mine Çetinkaya-Rundel to learn more about recent changes to my favorite R package. I learned quite a bit of new tricks and techniques for my everyday R coding and sharing a few of them here.  \n\nI'll use the `elm` data set from the **stats4nr** package as I work through a few examples in the post. This data set contains observations on 333 cedar elm trees (*Ulmus crassifolia* Nutt.) measured in Austin, Texas:\n\n```{r, warning = F, message =F}\nlibrary(tidyverse)\n\n#devtools::install_github(\"mbrussell/stats4nr\")\nlibrary(stats4nr)\n\ndata(elm)\n```\n\nHere are a few of the key points I took away from the video.\n\n\nR has a native pipe denoted as `|>`. The pipe is shorthand for saying “then.” In other words, you can say \"use my data frame, then make a new variable in it.\" Now, the native pipe is a part of the the tidyverse. \n\nIf you're a longtime user of the tidyverse, you might have been using `%>%`. Now, the pipe integrates with base R. For example, the code:\n\n```{r, eval = F}\nelm |> \n  summary()\n```\n\nprovides the same output as:\n\n```{r, eval = F}\nelm %>% \n  summary()\n```\n\nIf you're using RStudio, you can change the setting to use the native pipe by going to **Tools** -> **Global Options**, -> **Code**:\n\n# \n<center>\n\n![](pipe_operator.png){width=500px}\n</center>\n# \n\n### The lubridate package is now a part of the core tidyverse.\n\nIf your data contain a lot of dates and times, the **lubridate** package is your best friend. This package is now a part of the tidyverse and no longer needs to be called separately.\n\nThe **lubridate** package has several functions for working with date and time variables. For example, we can change strings of dates into year-month-date formats with the `ymd()` or `dmy()` functions:\n\n```{r}\nmy_date <- \"20230914\"\n\nmy_date2 <- \"14092023\"\n\nymd(my_date)\n\ndmy(my_date2)\n```\n\n\n### Easy ways to use a function in one package that's named the same in another package\n\nSeveral packages in R use functions with the same name, which can present problems when you tell R to use a function. You will often see this as a warning when you first load a library into your R session when there are functions of the same name from other packages. As [Mine mentions in her post](https://www.tidyverse.org/blog/2023/08/teach-tidyverse-23/), R will often *silently* choose the function from a package to use. \n\nFor example, the `lag()` function is available in both **dplyr** and the base R **stats** package. If we wanted to explicitly tell R to use this function from the **dplyr** package, we could write `dplyr::lag()`. But that could be repetitive if we use that function multiple times in our data analysis. \n\nNow with the `conflicts_prefer()` function from the **conflicted** package, you can tell R to use a specific function once, then forget about it for the rest of your analysis. For example, \n\n```{r}\nlibrary(conflicted)\nconflicts_prefer(dplyr::lag)\n```\n\nThis will choose the `lag()` function from **dplyr**. For example, say we wanted to use it to lag the tree diameter measurement in the **elm** data set:\n\n```{r}\nelm |> \n  mutate(DIA2 = lag(DIA)) |> \n  select(DIA, DIA2)\n```\n\n### New updates to joining variables\n\nIt seems like joining data sets is one of the most common tasks I do in my work, and tidyverse has new ways of doing this. The `join_by()` function can take the place of the `by =` statements. The good thing is there is no need to quote variable names anymore in the `by()` statement!\n\nFor example, say we have a data set that contains the codes for all open grown trees in the **elm** data set:\n\n```{r}\ncrown_class <- tribble(\n  ~crown_code, ~CROWN_CLASS_NAME,\n  1, \"Open grown\",\n  2, \"Not open grown\",\n  3, \"Not open grown\",\n  4, \"Not open grown\",\n  5, \"Not open grown\"\n)\n```\n\nThen we could join this to the elm data set. What I love about `join_by()` is there's no need to have the variable name the same in both data sets that you want to merge by. Note that the code indicating crown class is named *CROWN_CLASS_CD* in the **elm** data set and *crown_code* in the **crown_class** data set. It can be joined by expressing the double equal sign `==`:\n\n```{r}\nelm |>\n  left_join(crown_class, join_by(CROWN_CLASS_CD == crown_code)) |> \n  select(DIA, HT, CROWN_CLASS_CD, CROWN_CLASS_NAME)\n```\n\nThe join functions also have more ways to identify unmatched rows in your data. If this is of interest to you, explore the `unmatched = “drop”` and  `unmatched = “error”` statements. \n\n### New function to group variables \n\nA typical summary operation with **dplyr** code to obtain a mean and standard deviation of a variable might go something like:\n\n```{r}\nelm |> \n  group_by(CROWN_CLASS_CD) |> \n  summarize(mean_DIA = mean(DIA),\n            sd_DIA = sd(DIA))\n```\n\nNow, you can add a `.by` statement to add the grouping variable within the same call:\n\n```{r}\nelm |> \n  summarize(\n    mean_DIA = mean(DIA),\n    sd_DIA = sd(DIA),\n    .by = CROWN_CLASS_CD\n    )\n```\n\nI'm not sure how much this new technique will help in my analysis, but it does make sense to keep the functions within the same call. This may be particularly useful if there are more operations happening after the grouping.\n\n### New function to split columns and rows\n\nNew functions are available to help separate columns and rows into multiple columns or rows. For example, say we have a variable in the **elm** data set that separates the diameter and height measurements with a comma:\n\n```{r}\nelm |> \n  mutate(DIA_HT = paste0(DIA, \",\", HT)) |> \n  select(DIA, HT, DIA_HT)\n```\n\nThe `separate_wider_delim()` function separates columns into multiple one based on a delimiter. You can then rename the variables directly in the `names = ` statement:\n\n```{r}\nelm |> \n  mutate(DIA_HT = paste0(DIA, \",\", HT)) |> \n  separate_wider_delim(DIA_HT, \n                       delim = \",\",\n                       names = c(\"DIA2\", \"HT2\")) |> \n  select(DIA2, HT2)\n```\n\nThis can be a handy function, particularly for those that work with character strings that need to split them up into component parts. Note that the original variable that you separate (i.e., the *DIA_HT* variable) is dropped after you use the function.\n\n## Conclusion\n\nCheck out these new features in the tidyverse and try them in your own analysis. These new features are particularly well adapted for new learners of R/the tidyverse given they make more intuitive sense (and speed up performance). Let me know if any of the new techniques presented here help in your own data analysis.\n\n--\n\n*By Matt Russell. [Email Matt](mailto:matt@arbor-analytics.com) with any questions or comments.*\n","srcMarkdownNoYaml":"\n\n<center>\n\n![](hex-tidyverse.png){width=250px}\n</center>\n#  \n\nI recently watched the video [\"Teaching the tidyverse in 2023\"](https://youtu.be/KsBBRHAgAhM?si=Csp18DrhZhFe7r8x) by Mine Çetinkaya-Rundel to learn more about recent changes to my favorite R package. I learned quite a bit of new tricks and techniques for my everyday R coding and sharing a few of them here.  \n\nI'll use the `elm` data set from the **stats4nr** package as I work through a few examples in the post. This data set contains observations on 333 cedar elm trees (*Ulmus crassifolia* Nutt.) measured in Austin, Texas:\n\n```{r, warning = F, message =F}\nlibrary(tidyverse)\n\n#devtools::install_github(\"mbrussell/stats4nr\")\nlibrary(stats4nr)\n\ndata(elm)\n```\n\nHere are a few of the key points I took away from the video.\n\n### The native pipe works.\n\nR has a native pipe denoted as `|>`. The pipe is shorthand for saying “then.” In other words, you can say \"use my data frame, then make a new variable in it.\" Now, the native pipe is a part of the the tidyverse. \n\nIf you're a longtime user of the tidyverse, you might have been using `%>%`. Now, the pipe integrates with base R. For example, the code:\n\n```{r, eval = F}\nelm |> \n  summary()\n```\n\nprovides the same output as:\n\n```{r, eval = F}\nelm %>% \n  summary()\n```\n\nIf you're using RStudio, you can change the setting to use the native pipe by going to **Tools** -> **Global Options**, -> **Code**:\n\n# \n<center>\n\n![](pipe_operator.png){width=500px}\n</center>\n# \n\n### The lubridate package is now a part of the core tidyverse.\n\nIf your data contain a lot of dates and times, the **lubridate** package is your best friend. This package is now a part of the tidyverse and no longer needs to be called separately.\n\nThe **lubridate** package has several functions for working with date and time variables. For example, we can change strings of dates into year-month-date formats with the `ymd()` or `dmy()` functions:\n\n```{r}\nmy_date <- \"20230914\"\n\nmy_date2 <- \"14092023\"\n\nymd(my_date)\n\ndmy(my_date2)\n```\n\n\n### Easy ways to use a function in one package that's named the same in another package\n\nSeveral packages in R use functions with the same name, which can present problems when you tell R to use a function. You will often see this as a warning when you first load a library into your R session when there are functions of the same name from other packages. As [Mine mentions in her post](https://www.tidyverse.org/blog/2023/08/teach-tidyverse-23/), R will often *silently* choose the function from a package to use. \n\nFor example, the `lag()` function is available in both **dplyr** and the base R **stats** package. If we wanted to explicitly tell R to use this function from the **dplyr** package, we could write `dplyr::lag()`. But that could be repetitive if we use that function multiple times in our data analysis. \n\nNow with the `conflicts_prefer()` function from the **conflicted** package, you can tell R to use a specific function once, then forget about it for the rest of your analysis. For example, \n\n```{r}\nlibrary(conflicted)\nconflicts_prefer(dplyr::lag)\n```\n\nThis will choose the `lag()` function from **dplyr**. For example, say we wanted to use it to lag the tree diameter measurement in the **elm** data set:\n\n```{r}\nelm |> \n  mutate(DIA2 = lag(DIA)) |> \n  select(DIA, DIA2)\n```\n\n### New updates to joining variables\n\nIt seems like joining data sets is one of the most common tasks I do in my work, and tidyverse has new ways of doing this. The `join_by()` function can take the place of the `by =` statements. The good thing is there is no need to quote variable names anymore in the `by()` statement!\n\nFor example, say we have a data set that contains the codes for all open grown trees in the **elm** data set:\n\n```{r}\ncrown_class <- tribble(\n  ~crown_code, ~CROWN_CLASS_NAME,\n  1, \"Open grown\",\n  2, \"Not open grown\",\n  3, \"Not open grown\",\n  4, \"Not open grown\",\n  5, \"Not open grown\"\n)\n```\n\nThen we could join this to the elm data set. What I love about `join_by()` is there's no need to have the variable name the same in both data sets that you want to merge by. Note that the code indicating crown class is named *CROWN_CLASS_CD* in the **elm** data set and *crown_code* in the **crown_class** data set. It can be joined by expressing the double equal sign `==`:\n\n```{r}\nelm |>\n  left_join(crown_class, join_by(CROWN_CLASS_CD == crown_code)) |> \n  select(DIA, HT, CROWN_CLASS_CD, CROWN_CLASS_NAME)\n```\n\nThe join functions also have more ways to identify unmatched rows in your data. If this is of interest to you, explore the `unmatched = “drop”` and  `unmatched = “error”` statements. \n\n### New function to group variables \n\nA typical summary operation with **dplyr** code to obtain a mean and standard deviation of a variable might go something like:\n\n```{r}\nelm |> \n  group_by(CROWN_CLASS_CD) |> \n  summarize(mean_DIA = mean(DIA),\n            sd_DIA = sd(DIA))\n```\n\nNow, you can add a `.by` statement to add the grouping variable within the same call:\n\n```{r}\nelm |> \n  summarize(\n    mean_DIA = mean(DIA),\n    sd_DIA = sd(DIA),\n    .by = CROWN_CLASS_CD\n    )\n```\n\nI'm not sure how much this new technique will help in my analysis, but it does make sense to keep the functions within the same call. This may be particularly useful if there are more operations happening after the grouping.\n\n### New function to split columns and rows\n\nNew functions are available to help separate columns and rows into multiple columns or rows. For example, say we have a variable in the **elm** data set that separates the diameter and height measurements with a comma:\n\n```{r}\nelm |> \n  mutate(DIA_HT = paste0(DIA, \",\", HT)) |> \n  select(DIA, HT, DIA_HT)\n```\n\nThe `separate_wider_delim()` function separates columns into multiple one based on a delimiter. You can then rename the variables directly in the `names = ` statement:\n\n```{r}\nelm |> \n  mutate(DIA_HT = paste0(DIA, \",\", HT)) |> \n  separate_wider_delim(DIA_HT, \n                       delim = \",\",\n                       names = c(\"DIA2\", \"HT2\")) |> \n  select(DIA2, HT2)\n```\n\nThis can be a handy function, particularly for those that work with character strings that need to split them up into component parts. Note that the original variable that you separate (i.e., the *DIA_HT* variable) is dropped after you use the function.\n\n## Conclusion\n\nCheck out these new features in the tidyverse and try them in your own analysis. These new features are particularly well adapted for new learners of R/the tidyverse given they make more intuitive sense (and speed up performance). Let me know if any of the new techniques presented here help in your own data analysis.\n\n--\n\n*By Matt Russell. [Email Matt](mailto:matt@arbor-analytics.com) with any questions or comments.*\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","theme":{"light":"minty","dark":"slate"},"title-block-banner":true,"title":"Recent updates to tidyverse functions","author":"Matt Russell","description":"A few key updates from Teaching the tidyverse in 2023","date":"2023-09-14","slug":[],"categories":["Analytics"],"tags":["analytics","data science","R","tidyverse"],"image":"hex-tidyverse.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}