{
  "hash": "ed34046d97f31953e9b7b90ed722c03f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Recent updates to tidyverse functions\nauthor: Matt Russell\ndescription: \"A few key updates from Teaching the tidyverse in 2023\"\ndate: '2023-09-14'\nslug: []\ncategories:\n  - Analytics\ntags:\n  - analytics\n  - data science\n  - R\n  - tidyverse\nimage: hex-tidyverse.png\n---\n\n\n<center>\n\n![](hex-tidyverse.png){width=250px}\n</center>\n#  \n\nI recently watched the video [\"Teaching the tidyverse in 2023\"](https://youtu.be/KsBBRHAgAhM?si=Csp18DrhZhFe7r8x) by Mine Çetinkaya-Rundel to learn more about recent changes to my favorite R package. I learned quite a bit of new tricks and techniques for my everyday R coding and sharing a few of them here.  \n\nI'll use the `elm` data set from the **stats4nr** package as I work through a few examples in the post. This data set contains observations on 333 cedar elm trees (*Ulmus crassifolia* Nutt.) measured in Austin, Texas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n#devtools::install_github(\"mbrussell/stats4nr\")\nlibrary(stats4nr)\n\ndata(elm)\n```\n:::\n\n\nHere are a few of the key points I took away from the video.\n\n### The native pipe works.\n\nR has a native pipe denoted as `|>`. The pipe is shorthand for saying “then.” In other words, you can say \"use my data frame, then make a new variable in it.\" Now, the native pipe is a part of the the tidyverse. \n\nIf you're a longtime user of the tidyverse, you might have been using `%>%`. Now, the pipe integrates with base R. For example, the code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelm |> \n  summary()\n```\n:::\n\n\nprovides the same output as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelm %>% \n  summary()\n```\n:::\n\n\nIf you're using RStudio, you can change the setting to use the native pipe by going to **Tools** -> **Global Options**, -> **Code**:\n\n# \n<center>\n\n![](pipe_operator.png){width=500px}\n</center>\n# \n\n### The lubridate package is now a part of the core tidyverse.\n\nIf your data contain a lot of dates and times, the **lubridate** package is your best friend. This package is now a part of the tidyverse and no longer needs to be called separately.\n\nThe **lubridate** package has several functions for working with date and time variables. For example, we can change strings of dates into year-month-date formats with the `ymd()` or `dmy()` functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_date <- \"20230914\"\n\nmy_date2 <- \"14092023\"\n\nymd(my_date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2023-09-14\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndmy(my_date2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2023-09-14\"\n```\n\n\n:::\n:::\n\n\n\n### Easy ways to use a function in one package that's named the same in another package\n\nSeveral packages in R use functions with the same name, which can present problems when you tell R to use a function. You will often see this as a warning when you first load a library into your R session when there are functions of the same name from other packages. As [Mine mentions in her post](https://www.tidyverse.org/blog/2023/08/teach-tidyverse-23/), R will often *silently* choose the function from a package to use. \n\nFor example, the `lag()` function is available in both **dplyr** and the base R **stats** package. If we wanted to explicitly tell R to use this function from the **dplyr** package, we could write `dplyr::lag()`. But that could be repetitive if we use that function multiple times in our data analysis. \n\nNow with the `conflicts_prefer()` function from the **conflicted** package, you can tell R to use a specific function once, then forget about it for the rest of your analysis. For example, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(conflicted)\nconflicts_prefer(dplyr::lag)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n[conflicted] Will prefer dplyr::lag over any other package.\n```\n\n\n:::\n:::\n\n\nThis will choose the `lag()` function from **dplyr**. For example, say we wanted to use it to lag the tree diameter measurement in the **elm** data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelm |> \n  mutate(DIA2 = lag(DIA)) |> \n  select(DIA, DIA2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 333 × 2\n     DIA  DIA2\n   <dbl> <dbl>\n 1   5    NA  \n 2   5     5  \n 3   5.1   5  \n 4   5.1   5.1\n 5   5.1   5.1\n 6   5.1   5.1\n 7   5.2   5.1\n 8   5.2   5.2\n 9   5.2   5.2\n10   5.2   5.2\n# ℹ 323 more rows\n```\n\n\n:::\n:::\n\n\n### New updates to joining variables\n\nIt seems like joining data sets is one of the most common tasks I do in my work, and tidyverse has new ways of doing this. The `join_by()` function can take the place of the `by =` statements. The good thing is there is no need to quote variable names anymore in the `by()` statement!\n\nFor example, say we have a data set that contains the codes for all open grown trees in the **elm** data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrown_class <- tribble(\n  ~crown_code, ~CROWN_CLASS_NAME,\n  1, \"Open grown\",\n  2, \"Not open grown\",\n  3, \"Not open grown\",\n  4, \"Not open grown\",\n  5, \"Not open grown\"\n)\n```\n:::\n\n\nThen we could join this to the elm data set. What I love about `join_by()` is there's no need to have the variable name the same in both data sets that you want to merge by. Note that the code indicating crown class is named *CROWN_CLASS_CD* in the **elm** data set and *crown_code* in the **crown_class** data set. It can be joined by expressing the double equal sign `==`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelm |>\n  left_join(crown_class, join_by(CROWN_CLASS_CD == crown_code)) |> \n  select(DIA, HT, CROWN_CLASS_CD, CROWN_CLASS_NAME)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 333 × 4\n     DIA    HT CROWN_CLASS_CD CROWN_CLASS_NAME\n   <dbl> <dbl>          <dbl> <chr>           \n 1   5      32              4 Not open grown  \n 2   5      25              5 Not open grown  \n 3   5.1    21              5 Not open grown  \n 4   5.1    27              3 Not open grown  \n 5   5.1    22              3 Not open grown  \n 6   5.1    27              5 Not open grown  \n 7   5.2    29              3 Not open grown  \n 8   5.2    20              4 Not open grown  \n 9   5.2    18              3 Not open grown  \n10   5.2    17              3 Not open grown  \n# ℹ 323 more rows\n```\n\n\n:::\n:::\n\n\nThe join functions also have more ways to identify unmatched rows in your data. If this is of interest to you, explore the `unmatched = “drop”` and  `unmatched = “error”` statements. \n\n### New function to group variables \n\nA typical summary operation with **dplyr** code to obtain a mean and standard deviation of a variable might go something like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelm |> \n  group_by(CROWN_CLASS_CD) |> \n  summarize(mean_DIA = mean(DIA),\n            sd_DIA = sd(DIA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  CROWN_CLASS_CD mean_DIA sd_DIA\n           <dbl>    <dbl>  <dbl>\n1              1     7.5    3.29\n2              2    17.6    7.56\n3              3    10.9    5.10\n4              4     7.77   2.72\n5              5     7.09   2.04\n```\n\n\n:::\n:::\n\n\nNow, you can add a `.by` statement to add the grouping variable within the same call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelm |> \n  summarize(\n    mean_DIA = mean(DIA),\n    sd_DIA = sd(DIA),\n    .by = CROWN_CLASS_CD\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  CROWN_CLASS_CD mean_DIA sd_DIA\n           <dbl>    <dbl>  <dbl>\n1              4     7.77   2.72\n2              5     7.09   2.04\n3              3    10.9    5.10\n4              1     7.5    3.29\n5              2    17.6    7.56\n```\n\n\n:::\n:::\n\n\nI'm not sure how much this new technique will help in my analysis, but it does make sense to keep the functions within the same call. This may be particularly useful if there are more operations happening after the grouping.\n\n### New function to split columns and rows\n\nNew functions are available to help separate columns and rows into multiple columns or rows. For example, say we have a variable in the **elm** data set that separates the diameter and height measurements with a comma:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelm |> \n  mutate(DIA_HT = paste0(DIA, \",\", HT)) |> \n  select(DIA, HT, DIA_HT)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 333 × 3\n     DIA    HT DIA_HT\n   <dbl> <dbl> <chr> \n 1   5      32 5,32  \n 2   5      25 5,25  \n 3   5.1    21 5.1,21\n 4   5.1    27 5.1,27\n 5   5.1    22 5.1,22\n 6   5.1    27 5.1,27\n 7   5.2    29 5.2,29\n 8   5.2    20 5.2,20\n 9   5.2    18 5.2,18\n10   5.2    17 5.2,17\n# ℹ 323 more rows\n```\n\n\n:::\n:::\n\n\nThe `separate_wider_delim()` function separates columns into multiple one based on a delimiter. You can then rename the variables directly in the `names = ` statement:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelm |> \n  mutate(DIA_HT = paste0(DIA, \",\", HT)) |> \n  separate_wider_delim(DIA_HT, \n                       delim = \",\",\n                       names = c(\"DIA2\", \"HT2\")) |> \n  select(DIA2, HT2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 333 × 2\n   DIA2  HT2  \n   <chr> <chr>\n 1 5     32   \n 2 5     25   \n 3 5.1   21   \n 4 5.1   27   \n 5 5.1   22   \n 6 5.1   27   \n 7 5.2   29   \n 8 5.2   20   \n 9 5.2   18   \n10 5.2   17   \n# ℹ 323 more rows\n```\n\n\n:::\n:::\n\n\nThis can be a handy function, particularly for those that work with character strings that need to split them up into component parts. Note that the original variable that you separate (i.e., the *DIA_HT* variable) is dropped after you use the function.\n\n## Conclusion\n\nCheck out these new features in the tidyverse and try them in your own analysis. These new features are particularly well adapted for new learners of R/the tidyverse given they make more intuitive sense (and speed up performance). Let me know if any of the new techniques presented here help in your own data analysis.\n\n--\n\n*By Matt Russell. [Email Matt](mailto:matt@arbor-analytics.com) with any questions or comments.*\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}