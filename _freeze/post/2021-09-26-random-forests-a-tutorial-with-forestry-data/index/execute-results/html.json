{
  "hash": "6914e82aadb4194c6dc77d8c8ad0918c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Random forests: a tutorial with forestry data'\nauthor: Matt Russell\ndate: '2021-09-27'\nslug: []\ncategories:\n  - Analytics\ntags:\n  - analytics\n  - Data science\n  - random forests\n  - statistics\n---\n\n\n<center>\n![](bootstrap_rf.png){width=500px}\n</center>\n\n#  \n# \n\nRandom forests have quickly become [one of the most popular analytical techniques](https://arbor-analytics.com/post/random-forests-in-a-nutshell/) used in forestry today. Random forests (RF) are a machine learning technique that differ in many ways to traditional prediction models such as regression. Random forests can handle a lot of data, can be applied to classification or regression problems, and rank the relative importance of many variables that are related to a response variable of interest.\n\nI've written about the [theory behind random forests](https://arbor-analytics.com/post/random-forests-in-a-nutshell/). This post will present a tutorial of using random forests in R. \n\n\n## The Parresol tree biomass data\n\nAs an example, we'll use a data set of 40 slash pine trees from Louisiana USA presented in Parresol's 2001 paper [*Additivity of nonlinear biomass equations*](https://cdnsciencepub.com/doi/10.1139/x00-202). The data are presented in Table 1 of the paper, which is replicated in [this Google Sheet](https://docs.google.com/spreadsheets/d/1TPutUVyZLWr7XopKguT5Nvh9lo1EOG4wvOZ6_lD1F_M/edit?usp=sharing).\n\nWe'll read in the data using the `read_sheet()` function from the **googlesheets4** package. We will also load the **tidyverse** package to use some of its plotting features:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(googlesheets4)\n\ntree <- read_sheet(\"https://docs.google.com/spreadsheets/d/1TPutUVyZLWr7XopKguT5Nvh9lo1EOG4wvOZ6_lD1F_M/edit?usp=sharing\")\n```\n:::\n\n\nThe data contain the following variables:\n\n* `TreeID`: Tree observation record,\n* `DBH`: Tree diameter at breast height, cm,\n* `HT`: Tree height, m,\n* `LCL`: Tree live crown length, m,\n* `Age`: Age of the tree, years,\n* `Mass_wood`: Green mass of the wood in the tree, kg,\n* `Mass_bark`: Green mass of the bark in the tree, kg,\n* `Mass_crown`: Green mass of the crown of the tree, kg, and\n* `Mass_tree`: Green mass of all tree components, kg.\n\nOur ultimate interest is in predicting the mass all tree components using common tree measurements such as tree diameter, height, live crown length, and age. Before we start modeling with the data, it is a good practice to first visualize the variables. The `ggpairs()` function from the **GGally** package is a useful tool that visualizes the distribution and correlation between variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(GGally)\n\nggpairs(tree, columns = c(2:5, 9))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nYou can see a few variables have strong positive correlations with the mass of the tree (e.g., height and diameter) and some more moderate positive correlations (e.g., age).\n\n## The randomForest R package\n\nR and Python both have numerous packages that implement random forests. In R alone, there are nearly 400 packages with the word \"tree\" or \"forest\" in their name. (Sidebar: This is not ideal if you're a forest analyst of biometrician because [only 31 of them](https://arbor-analytics.com/post/31-r-packages-for-forest-analysts/) are actually about forestry.)\n\nBreiman [wrote about random forests in 2001](https://link.springer.com/article/10.1023/A:1010933404324) and a year later [Liaw and Wiener](https://cogns.northwestern.edu/cbmg/LiawAndWiener2002.pdf) created an R package that implements the technique. To date, the **randomForest** R package remains one of the most popular ones in machine learning. \n \nWe can install and load the **randomForest** package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"randomForest\")\nlibrary(randomForest)\n```\n:::\n\n\nWe will use the `randomForest()` function to predict total tree mass using several variables in the **tree** data set. A few other key statements to use in the `randomForest()` function are:\n\n* `keep.forest = T`: This will save the random forest output, which will be helpful in summarizing the results.\n* `importance = TRUE`: This will assess the importance of each of the predictors, essential output in random forests!\n* `mtry = 1`: This tells the function to randomly sample one variable at each split in the random forest. For applications in regression, the default value is the number of predictor variables divided by three (and rounded down). In the modeling, several small samples of the entire data set are taken. Any observations that are not taken are called “out-of-bag” samples.\n* `ntree = 500`. This tells the function to grow 500 trees. Generally, a larger number of trees will produce more stable estimates. However, increasing the number of trees needs to be done with consideration of time and memory issues when dealing with large data sets. \n\nOur response variable in the random forests model is `Mass_tree` and predictors are `DBH`, `HT`, `LCL`, and `Age`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree.rf <- randomForest(Mass_tree ~ DBH + HT + LCL + Age,\n                        data = tree,\n                        keep.forest = T,\n                        importance = TRUE, \n                        mtry = 1,\n                        ntree = 500)\ntree.rf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\n randomForest(formula = Mass_tree ~ DBH + HT + LCL + Age, data = tree,      keep.forest = T, importance = TRUE, mtry = 1, ntree = 500) \n               Type of random forest: regression\n                     Number of trees: 500\nNo. of variables tried at each split: 1\n\n          Mean of squared residuals: 9415.002\n                    % Var explained: 87.27\n```\n\n\n:::\n:::\n\n\nNote the mean of squared residuals and the percent variation explained (analogous to R-squared) provided in the output. (We'll revisit them later.)\n\nAnother way to visualize the out-of-bag error rates of the random forests models is to use the `plot()` function. In this application, although we specified 500 trees, the out-of-bag error generally stabilizes after 100 trees:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(tree.rf)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nSome of the most helpful output in random forests is the importance of each of the predictor variables. The importance score is calculated by evaluating the regression tree with and without that variable. When evaluating the regression tree, the mean square error (MSE) will go up, down, or stay the same.\n\nIf the percent increase in MSE after removing the variable is large, it indicates an important variable. If the percent increase in MSE after removing the variable is small, it’s less important.\n\nThe `importance()` function prints the importance scores for each variable and the `varImpPlot()` function plots them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimportance(tree.rf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      %IncMSE IncNodePurity\nDBH 17.507804      880292.7\nHT  15.296300      807963.8\nLCL 13.388462      639453.3\nAge  8.131857      408963.7\n```\n\n\n:::\n\n```{.r .cell-code}\nvarImpPlot(tree.rf,type=1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nThe output indicates that `DBH` is the most important variable for predicting `Mass_tree` and age the least important. \n\n## Comparing random forests and regression models\n\nForest analysts are often compare multiple models and determine which one has a better predictive ability. In this case, we can fit a multiple linear regression model to the data and compare to the random forests model.\n\nThe `lm()` function can be used to develop a parametric model for `Mass_tree`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree.reg <- lm(Mass_tree ~ DBH + HT + LCL + Age, data = tree)\nsummary(tree.reg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = Mass_tree ~ DBH + HT + LCL + Age, data = tree)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-136.285  -57.177   -9.399   43.822  189.758 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept) -545.374     67.916  -8.030 1.89e-09 ***\nDBH           40.523      5.778   7.013 3.68e-08 ***\nHT           -15.048      8.079  -1.862   0.0709 .  \nLCL            2.490     12.259   0.203   0.8402    \nAge           15.431      3.198   4.825 2.72e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 82.33 on 35 degrees of freedom\nMultiple R-squared:  0.9198,\tAdjusted R-squared:  0.9106 \nF-statistic: 100.4 on 4 and 35 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\nNote the residual standard error of 82.33 kg and the adjusted R-squared of 0.91. The residual standard error is slightly lower and the R-squared value slightly higher for the multiple regression model compared to the random forest output. In addition, further work may be conducted on the multiple regression model by removing the non-significant variables and refitting the model.\n\nAnother aspect of model evaluation is comparing predictions. Although random forests models are often considered a “black box” method because their results are not easily interpreted, the `predict()` function provides predictions of total tree mass:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMass_pred_rf <- predict(tree.rf, tree, predict.all = F)\nMass_pred_reg <- predict(tree.reg, tree, predict.all = F)\n```\n:::\n\n\nIn an ideal setting we might test our model on an independent data set not used in model fitting. However, we can combine the predicted tree weights from both models to the **tree** data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree2 <- as.data.frame(cbind(tree, Mass_pred_rf, Mass_pred_reg))\n```\n:::\n\n\nNote that some predictions from the linear regression model on the 40 trees provide negative values for predicted total tree mass, an undesirable feature that may need to be addressed before implementing the model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree2 %>% \n  summarize(Mass_tree, Mass_pred_rf, Mass_pred_reg)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Mass_tree Mass_pred_rf Mass_pred_reg\n1        9.8     25.21493   -108.051811\n2       12.1     25.05643    -86.903051\n3       24.4     40.88979    -62.814807\n4       27.0     34.52743    -42.513067\n5       33.6     43.41506     -7.391764\n6       43.5     45.98330     -8.814627\n7       46.0     99.98358    168.354603\n8       56.1     77.63545     -8.073626\n9       64.4     65.60557     47.563293\n10      70.8    108.85428     64.024945\n11      75.9    111.52683    189.278688\n12      88.7     84.93915    103.439719\n13      95.7    102.76580     18.126885\n14     102.4    143.41118    238.684823\n15     123.7    145.36054     90.880242\n16     147.6    176.06111    261.258307\n17     148.5    143.53247    174.276553\n18     174.8    170.33346    186.750002\n19     193.0    169.30845    199.939638\n20     211.7    207.50296    306.293014\n21     214.6    269.89235    186.964881\n22     225.3    245.55534    240.537957\n23     244.7    247.63206    277.932654\n24     258.2    289.27981    263.034375\n25     285.8    259.22561    363.444771\n26     297.6    285.91326    317.816460\n27     309.8    270.94465    366.051168\n28     316.2    342.13331    392.605018\n29     318.0    314.38717    283.934957\n30     401.1    424.69591    399.000959\n31     402.2    389.01151    463.875242\n32     411.9    401.71263    450.015697\n33     446.3    467.22418    458.158909\n34     490.3    419.49775    546.871939\n35     522.6    519.87912    583.516204\n36     522.7    472.62866    519.012527\n37     593.6    580.70856    652.592720\n38     900.3    788.07493    714.152257\n39    1034.9    892.33950    845.142484\n40    1198.5   1006.03689   1095.330861\n```\n\n\n:::\n:::\n\n\nWe may also be interested in plotting residual values from both model types to compare their performance: \n\n\n::: {.cell}\n\n```{.r .cell-code}\np.rf <- ggplot(tree2, (aes(x = Mass_pred_rf, y = Mass_tree - Mass_pred_rf))) +\n  geom_point() + \n  scale_y_continuous(limits = c(-200, 200)) +\n  labs(x = \"Predicted tree mass (kg)\",\n       y = \"Residual (kg)\",\n       subtitle = \"Random forests model\") \n\np.reg <- ggplot(tree2, (aes(x = Mass_pred_reg, y = Mass_tree - Mass_pred_reg))) +\n  geom_point() + \n  scale_y_continuous(limits = c(-200, 200)) +\n  labs(x = \"Predicted tree mass (kg)\",\n       y = \"Residual (kg)\",\n       subtitle = \"Regression model\") \n\nlibrary(patchwork)\n\np.rf + p.reg\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nWith the heteroscedastic residuals in the models, we'd likely want to explore transforming the data prior to model fitting, or to explore other modeling techniques. \n\n## Summary\n\nRandom forests techniques are flexible and can perform comparably with other regression or classification methods. Random forests can handle all types of data (e.g., categorical, continuous) and are advantageous because they work well with data sets containing a large number of predictor variables. The **randomForest** package has seen a lot of development and can be used to help solve modeling problems in your future forest analytics work. \n\n--\n\n*By Matt Russell. [Email Matt](mailto:matt@arbor-analytics.com) with any questions or comments. Sign up for my [monthly newsletter](https://mailchi.mp/d96897dc0f46/arbor-analytics) for in-depth analysis on data and analytics in the forest products industry.*",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}